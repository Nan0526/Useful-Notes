# OPA - Open Policy Agent
## Overview
OPA decouples policy decision-making from policy enforcement. When your software needs to make policy decisions it queries OPA and supplies structured data (e.g., JSON) as input. OPA accepts arbitrary structured data as input.   
理解：Services send JSON类似的data 到OPA, OPQ做了decisions之后，把decisions返给services.   
OPA可以做而且不限于以下decisions：
- Which users can access which resources.
- Which subnets egress traffic is allowed to.
- Which clusters a workload must be deployed to.
- Which registries binaries can be downloaded from.
- Which OS capabilities a container can execute with.
- Which times of day the system can be accessed at.

## Example
![example](https://user-images.githubusercontent.com/36396754/102041966-92563500-3d85-11eb-9d34-7996913187e7.png)

There are 3 kinds of components in the system:
- Servers expose zero or more protocols (e.g., http, ssh, etc.)
- Networks connect servers and can be public or private. Public networks are connected to the Internet.
- Ports attach servers to networks.    
All of the servers, networks, and ports are provisioned by a script. The script receives a JSON representation of the system as input:    
理解：这就是services send给OPA的东西？
```
{
    "servers": [
        {"id": "app", "protocols": ["https", "ssh"], "ports": ["p1", "p2", "p3"]},
        {"id": "db", "protocols": ["mysql"], "ports": ["p3"]},
        {"id": "cache", "protocols": ["memcache"], "ports": ["p3"]},
        {"id": "ci", "protocols": ["http"], "ports": ["p1", "p2"]},
        {"id": "busybox", "protocols": ["telnet"], "ports": ["p1"]}
    ],
    "networks": [
        {"id": "net1", "public": false},
        {"id": "net2", "public": false},
        {"id": "net3", "public": true},
        {"id": "net4", "public": true}
    ],
    "ports": [
        {"id": "p1", "network": "net1"},
        {"id": "p2", "network": "net3"},
        {"id": "p3", "network": "net2"}
    ]
}
```
## Rego
OPA policies are expressed in a language callded Rego.   
When OPA evaluates policies it binds data provided in the query to a global variable called `input`.    
```rego
input.servers[0].protocols[0]
```
```bash
"https"
```
### Rego 的一些常见语法
#### Expressions 
同样也是用 `==`，但是似乎return的东西是 `true` 或者 `undefined`
#### Variables 赋值
用 `:=`。不能赋值两次。
#### Iterations
```rego
some i, j; input.servers[i].protocols[j] == "http"
```
```bash
+---+---+
| i | j |
+---+---+
| 3 | 0 |
+---+---+
```
## Rules
Rules are just if-then logic statements. Rules can either be "complete" or "partial".   
理解：if ..一些条件满足... then 某个variable会被赋值
### Complete Rules
Complete rules are if-then statements that assign a **single** value to a variable. For example:   
```rego
package example.rules

any_public_networks = true {  # is true if...
    net := input.networks[_]  # some network exists and..
    net.public                # it is public.
}
```
可以省略 `= true`    
If you omit the = <value> part of the rule head the value defaults to true. You could rewrite the example above as follows without changing the meaning:        

```rego
package example.rules

any_public_networks {
    net := input.networks[_]
    net.public
}
```
```rego
any_public_networks
```
```bash
true
```
**All values generated by rules can be quried via the global `data` variable.**   
```
data.example.rules.any_public_networks
```
```
true
```
You can query the value of any rule loaded into OPA by referring to it with an absolute path. The path of a rule is always: `data.<package-path>.<rule-name>`. 
需要好好理解这句话！！！！！    
所以意思是OPA里面可以有很多个packages，每个package有很多rules, 每个rule的赋值 variable都可以globally访问？？  
### Partial Rules
Partial rules are if-then statements that generate **a set of values** and assign that set to a variable. For example:   
```rego
package example.rules

public_network[net.id] {      # net.id is in the public_network set if...
    net := input.networks[_]  # some network exists and...
    net.public                # it is public.
}
```
```rego
public_network
```
```
[
  "net3",
  "net4"
]
```
You can iterate over the set of values by referencing the set elements with a variable:    
```rego
some n; public_network[n]
```
```
+--------+-------------------+
|   n    | public_network[n] |
+--------+-------------------+
| "net3" | "net3"            |
| "net4" | "net4"            |
+--------+-------------------+
```
(**这里让我很疑惑的地方是：为什么n不代表index呢？而是直接代表里面的element?是因为set的缘故吗？？**)   
